const fs = require('fs');
const path = require('path');
const { jsPDF } = require('jspdf');
const { Document, Packer, Paragraph, TextRun } = require('docx');
const ExcelJS = require('exceljs');
const uploadToFTP = require('./ftpUploader');

class FileGenerator {
  // âœ… FIXED: AI file generation with better content validation
  static async generateFromAI(fileType, content, filename, conversation_id, user_id) {
    try {
      console.log(`ğŸ¤– AI generating ${fileType}: ${filename}`);
      console.log(`ğŸ“ Content received (${content.length} chars)`);
      console.log(`ğŸ“„ Content preview: ${content.substring(0, 500)}...`);
      
      // âœ… Use content exactly as provided by AI
      const actualContent = content.trim();
      
      if (!actualContent || actualContent.length < 10) {
        throw new Error(`Content is too short: ${actualContent.length} characters`);
      }
      
      // âœ… Ensure proper filename without double extensions
      const cleanFilename = filename.replace(/\.(pdf|docx|xlsx|txt)$/i, '');
      
      // Generate file based on type with COMPLETE CONTENT
      let fileData;
      switch (fileType.toLowerCase()) {
        case 'pdf':
          fileData = await this.generatePDF(actualContent, `${cleanFilename}.pdf`);
          break;
        case 'docx':
        case 'word':
          fileData = await this.generateWord(actualContent, `${cleanFilename}.docx`);
          break;
        case 'xlsx':
        case 'excel':
          fileData = await this.generateExcel(actualContent, `${cleanFilename}.xlsx`);
          break;
        case 'txt':
          fileData = await this.generateTXT(actualContent, `${cleanFilename}.txt`);
          break;
        default:
          throw new Error(`Unsupported file type: ${fileType}`);
      }

      // Upload to FTP
      console.log(`ğŸ“¤ Uploading to FTP: ${fileData.filename}`);
      const ftpResult = await uploadToFTP(fileData.buffer, fileData.filename);
      
      // âœ… FIXED: Handle FTP result properly
      let ftpPath;
      let actualFilename;
      
      console.log(`ğŸ” FTP Result:`, ftpResult);
      
      if (typeof ftpResult === 'string') {
        ftpPath = ftpResult;
        actualFilename = ftpPath.split('/').pop();
      } else if (ftpResult && typeof ftpResult === 'object') {
        ftpPath = ftpResult.path || ftpResult.ftpPath || `/fileuploads/files/${fileData.filename}`;
        actualFilename = ftpResult.filename || ftpPath.split('/').pop();
      } else {
        actualFilename = fileData.filename;
        ftpPath = `/fileuploads/files/${actualFilename}`;
      }
      
      const downloadUrl = `https://qhashai.com${ftpPath}`;
      
      console.log(`âœ… File uploaded to FTP: ${ftpPath}`);
      console.log(`ğŸ“ Actual filename: ${actualFilename}`);
      console.log(`ğŸ”— Download URL generated: ${downloadUrl}`);
      
      return {
        success: true,
        filename: actualFilename, // Use actual FTP filename
        originalFilename: cleanFilename, // Keep original for display
        fileType: fileType,
        size: fileData.size,
        mimeType: fileData.mimeType,
        ftpPath: ftpPath,
        downloadUrl: downloadUrl,
        buffer: fileData.buffer
      };

    } catch (error) {
      console.error(`âŒ File generation failed:`, error);
      throw error;
    }
  }

  // âœ… FIXED: PDF Generation with ACTUAL content
  // static async generatePDF(content, filename) {
  //   const doc = new jsPDF();
  //   const pageWidth = doc.internal.pageSize.width;
  //   const pageHeight = doc.internal.pageSize.height;
  //   const margin = 20;
  //   let yPosition = 30;
    
  //   // âœ… Add the ACTUAL content from AI
  //   doc.setFontSize(12);
  //   const lines = doc.splitTextToSize(content, pageWidth - 2*margin);
    
  //   lines.forEach(line => {
  //     if (yPosition > pageHeight - 30) {
  //       doc.addPage();
  //       yPosition = 30;
  //     }
  //     doc.text(line, margin, yPosition);
  //     yPosition += 7;
  //   });
    
  //   // Add footer
  //   doc.setFontSize(8);
  //   doc.text(`Generated by QhashAI - ${new Date().toLocaleDateString()}`, margin, pageHeight - 20);
    
  //   const buffer = Buffer.from(doc.output('arraybuffer'));
  //   return { buffer, filename, mimeType: 'application/pdf', size: buffer.length };
  // }
static async generatePDF(content, filename) {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  const margin = 20;
  let yPosition = 30;
  
  // âœ… Process content line by line with formatting
  const lines = content.split('\n');
  
  lines.forEach(line => {
    if (yPosition > pageHeight - 30) {
      doc.addPage();
      yPosition = 30;
    }
    
    // âœ… ENHANCED: Handle bold formatting in PDF
    if (line.includes('**')) {
      // Parse bold formatting
      const parts = line.split(/(\*\*.*?\*\*)/);
      let xPosition = margin;
      
      parts.forEach(part => {
        if (part.startsWith('**') && part.endsWith('**')) {
          // Bold text
          const boldText = part.slice(2, -2);
          doc.setFont(undefined, 'bold');
          doc.setFontSize(12);
          doc.text(boldText, xPosition, yPosition);
          xPosition += doc.getTextWidth(boldText);
        } else if (part.trim()) {
          // Normal text
          doc.setFont(undefined, 'normal');
          doc.setFontSize(12);
          doc.text(part, xPosition, yPosition);
          xPosition += doc.getTextWidth(part);
        }
      });
    } else {
      // Regular line without formatting
      doc.setFont(undefined, 'normal');
      doc.setFontSize(12);
      const wrappedLines = doc.splitTextToSize(line, pageWidth - 2*margin);
      wrappedLines.forEach(wrappedLine => {
        if (yPosition > pageHeight - 30) {
          doc.addPage();
          yPosition = 30;
        }
        doc.text(wrappedLine, margin, yPosition);
        yPosition += 7;
      });
      yPosition -= 7; // Adjust since we'll add 7 at the end
    }
    
    yPosition += 7;
  });
  
  // Add footer
  doc.setFontSize(8);
  doc.setFont(undefined, 'italic');
  doc.text(`Generated by QhashAI - ${new Date().toLocaleDateString()}`, margin, pageHeight - 20);
  
  const buffer = Buffer.from(doc.output('arraybuffer'));
  return { buffer, filename, mimeType: 'application/pdf', size: buffer.length };
}
  // âœ… FIXED: Word Generation with complete content preservation
//   static async generateWord(content, filename) {
//   console.log(`ğŸ“ Generating Word with content: ${content.length} characters`);
//   console.log(`ğŸ“„ FULL Content to include: ${content}`);
  
//   // âœ… Split content into paragraphs and preserve ALL formatting
//   const lines = content.split('\n');
//   const children = [];
  
//   console.log(`ğŸ“„ Processing ${lines.length} lines:`);
//   lines.forEach((line, index) => {
//     console.log(`   Line ${index + 1}: "${line}"`);
//   });
  
//   // âœ… Add each line as a paragraph
//   lines.forEach((line, index) => {
//     if (line.trim() === '') {
//       // Add empty paragraph for spacing
//       children.push(new Paragraph({
//         children: [new TextRun({ text: " ", size: 24 })],
//         spacing: { after: 100 }
//       }));
//     } else {
//       children.push(new Paragraph({
//         children: [new TextRun({ text: line, size: 24 })],
//         spacing: { after: 150 }
//       }));
//     }
//   });
  
//   // Add footer
//   children.push(new Paragraph({
//     children: [new TextRun({ 
//       text: `\nGenerated by QhashAI - ${new Date().toLocaleDateString()}`, 
//       size: 18, 
//       italics: true 
//     })],
//     spacing: { before: 400 }
//   }));

//   const doc = new Document({
//     sections: [{
//       children: children
//     }]
//   });

//   const buffer = await Packer.toBuffer(doc);
//   console.log(`âœ… Word document generated: ${buffer.length} bytes with ${lines.length} lines`);
  
//   return { 
//     buffer, 
//     filename, 
//     mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 
//     size: buffer.length 
//   };
// }
static async generateWord(content, filename) {
  console.log(`ğŸ“ Generating Word with content: ${content.length} characters`);
  console.log(`ğŸ“„ FULL Content to include: ${content}`);
  
  // âœ… Split content into paragraphs and preserve ALL formatting
  const lines = content.split('\n');
  const children = [];
  
  console.log(`ğŸ“„ Processing ${lines.length} lines:`);
  lines.forEach((line, index) => {
    console.log(`   Line ${index + 1}: "${line}"`);
  });
  
  // âœ… Add each line as a paragraph with proper formatting
  lines.forEach((line, index) => {
    if (line.trim() === '') {
      // Add empty paragraph for spacing
      children.push(new Paragraph({
        children: [new TextRun({ text: " ", size: 24 })],
        spacing: { after: 100 }
      }));
    } else {
      // âœ… ENHANCED: Parse markdown-style formatting
      const textRuns = parseFormattedText(line);
      
      children.push(new Paragraph({
        children: textRuns,
        spacing: { after: 150 }
      }));
    }
  });
  
  // Add footer
  children.push(new Paragraph({
    children: [new TextRun({ 
      text: `\nGenerated by QhashAI - ${new Date().toLocaleDateString()}`, 
      size: 18, 
      italics: true 
    })],
    spacing: { before: 400 }
  }));

  const doc = new Document({
    sections: [{
      children: children
    }]
  });

  const buffer = await Packer.toBuffer(doc);
  console.log(`âœ… Word document generated: ${buffer.length} bytes with ${lines.length} lines`);
  
  return { 
    buffer, 
    filename, 
    mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 
    size: buffer.length 
  };
}


 // âœ… ENHANCED: Excel Generation with bold formatting and better table handling
static async generateExcel(content, filename) {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('Document');
  
  // âœ… Parse content and organize into columns
  const lines = content.split('\n').filter(line => line.trim());
  
  let currentRow = 1;
  let isFirstTableRow = true;
  
  lines.forEach((line) => {
    const trimmedLine = line.trim();
    
    // âœ… SKIP TABLE SEPARATOR LINES (lines with dashes)
    if (trimmedLine.match(/^[-\s|]+$/)) {
      console.log(`ğŸ“‹ Skipping table separator line: ${trimmedLine}`);
      return; // Skip this line, don't increment currentRow
    }
    
    // âœ… ENHANCED: Handle pipe-separated values with bold formatting
    if (trimmedLine.includes('|')) {
      console.log(`ğŸ“‹ Processing table row ${currentRow}: ${trimmedLine}`);
      
      // Handle pipe-separated values (e.g., "**Name** | **Age** | **City**")
      const parts = trimmedLine.split('|').map(part => part.trim());
      
      parts.forEach((part, index) => {
        const columnLetter = String.fromCharCode(65 + index); // A, B, C, etc.
        const cell = worksheet.getCell(`${columnLetter}${currentRow}`);
        
        // âœ… ENHANCED: Check for bold formatting
        if (part.startsWith('**') && part.endsWith('**')) {
          // Remove ** and make cell bold
          const boldText = part.slice(2, -2);
          cell.value = boldText;
          cell.font = { bold: true, size: 12 };
          
          // âœ… ENHANCED: Style header cells differently
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE6E6FA' } // Light purple background for headers
          };
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
        } else {
          // Regular text - check if it's a number for better formatting
          const numericValue = parseFloat(part);
          if (!isNaN(numericValue) && part.match(/^\d+(\.\d+)?$/)) {
            cell.value = numericValue;
            cell.numFmt = '0'; // Format as number
          } else {
            cell.value = part;
          }
          
          cell.font = { size: 11 };
          cell.alignment = { 
            horizontal: isFirstTableRow ? 'center' : 'left', 
            vertical: 'middle' 
          };
        }
        
        // âœ… Add borders to all cells
        cell.border = {
          top: { style: 'thin', color: { argb: 'FF000000' } },
          left: { style: 'thin', color: { argb: 'FF000000' } },
          bottom: { style: 'thin', color: { argb: 'FF000000' } },
          right: { style: 'thin', color: { argb: 'FF000000' } }
        };
      });
      
      isFirstTableRow = false; // After first row, subsequent rows are data
    } else if (trimmedLine.includes(':')) {
      // Handle key-value pairs (e.g., "**Name:** John", "Age: 25")
      const parts = trimmedLine.split(':');
      if (parts.length >= 2) {
        const keyCell = worksheet.getCell(`A${currentRow}`);
        const valueCell = worksheet.getCell(`B${currentRow}`);
        
        const key = parts[0].trim();
        const value = parts.slice(1).join(':').trim();
        
        // âœ… ENHANCED: Handle bold keys
        if (key.startsWith('**') && key.endsWith('**')) {
          keyCell.value = key.slice(2, -2);
          keyCell.font = { bold: true, size: 11 };
        } else {
          keyCell.value = key;
          keyCell.font = { size: 11 };
        }
        
        // âœ… ENHANCED: Handle bold values
        if (value.startsWith('**') && value.endsWith('**')) {
          valueCell.value = value.slice(2, -2);
          valueCell.font = { bold: true, size: 11 };
        } else {
          valueCell.value = value;
          valueCell.font = { size: 11 };
        }
        
        // Add borders
        [keyCell, valueCell].forEach(cell => {
          cell.border = {
            top: { style: 'thin', color: { argb: 'FF000000' } },
            left: { style: 'thin', color: { argb: 'FF000000' } },
            bottom: { style: 'thin', color: { argb: 'FF000000' } },
            right: { style: 'thin', color: { argb: 'FF000000' } }
          };
          cell.alignment = { vertical: 'middle', wrapText: true };
        });
      } else {
        // Single column for lines with colon but not key-value
        const cell = worksheet.getCell(`A${currentRow}`);
        if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
          cell.value = trimmedLine.slice(2, -2);
          cell.font = { bold: true, size: 12 };
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFF0F8FF' } // Light blue background for bold headers
          };
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
        } else {
          cell.value = trimmedLine;
          cell.font = { size: 11 };
        }
        
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      }
    } else if (trimmedLine.includes('\t')) {
      // Handle tab-separated values
      const parts = trimmedLine.split('\t').map(part => part.trim());
      parts.forEach((part, index) => {
        const columnLetter = String.fromCharCode(65 + index);
        const cell = worksheet.getCell(`${columnLetter}${currentRow}`);
        
        if (part.startsWith('**') && part.endsWith('**')) {
          cell.value = part.slice(2, -2);
          cell.font = { bold: true, size: 11 };
        } else {
          cell.value = part;
          cell.font = { size: 11 };
        }
        
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
    } else if (trimmedLine.includes(',') && trimmedLine.split(',').length > 2) {
      // Handle comma-separated values (only if more than 2 parts to avoid splitting sentences)
      const parts = trimmedLine.split(',').map(part => part.trim());
      parts.forEach((part, index) => {
        const columnLetter = String.fromCharCode(65 + index);
        const cell = worksheet.getCell(`${columnLetter}${currentRow}`);
        
        if (part.startsWith('**') && part.endsWith('**')) {
          cell.value = part.slice(2, -2);
          cell.font = { bold: true, size: 11 };
        } else {
          cell.value = part;
          cell.font = { size: 11 };
        }
        
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
    } else {
      // âœ… Single column for regular text with bold formatting support
      const cell = worksheet.getCell(`A${currentRow}`);
      
      if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
        // Full line is bold - likely a title
        cell.value = trimmedLine.slice(2, -2);
        cell.font = { bold: true, size: 14 }; // Larger font for titles
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFD3D3D3' } // Light gray background for titles
        };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        
        // âœ… Merge title across multiple columns if this is a table document
        const nextRowHasPipes = lines[lines.indexOf(line) + 1]?.includes('|');
        if (nextRowHasPipes) {
          const columnsCount = lines[lines.indexOf(line) + 1].split('|').length;
          const lastColumn = String.fromCharCode(64 + columnsCount);
          worksheet.mergeCells(`A${currentRow}:${lastColumn}${currentRow}`);
        }
      } else if (trimmedLine.includes('**')) {
        // âœ… ENHANCED: Handle mixed bold and regular text in same cell
        const cleanText = trimmedLine.replace(/\*\*(.*?)\*\*/g, '$1');
        cell.value = cleanText;
        cell.font = { size: 11 };
        cell.alignment = { horizontal: 'left', vertical: 'middle' };
      } else {
        // Regular text
        cell.value = trimmedLine;
        cell.font = { size: 11 };
        cell.alignment = { horizontal: 'left', vertical: 'middle' };
      }
      
      // Add border
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    }
    
    currentRow++;
  });
  
  // âœ… ENHANCED: Auto-fit columns with better sizing
  worksheet.columns.forEach((column, index) => {
    let maxLength = 0;
    column.eachCell({ includeEmpty: false }, (cell) => {
      const cellLength = cell.value ? cell.value.toString().length : 0;
      if (cellLength > maxLength) {
        maxLength = cellLength;
      }
    });
    
    // âœ… Better column width calculation
    const calculatedWidth = Math.min(Math.max(maxLength + 3, 12), 60); // Min 12, Max 60
    column.width = calculatedWidth;
  });
  
  // âœ… Set consistent row height for better readability
  worksheet.eachRow((row, rowNumber) => {
    row.height = 22; // Set consistent row height
  });
  
  // âœ… ENHANCED: Add professional footer with styling
  const footerRow = currentRow + 2;
  const footerCell = worksheet.getCell(`A${footerRow}`);
  footerCell.value = `Generated by QhashAI - ${new Date().toLocaleDateString()}`;
  footerCell.font = { italics: true, size: 10, color: { argb: 'FF666666' } };
  footerCell.alignment = { horizontal: 'center' };
  
  // âœ… Merge footer across multiple columns if there are multiple columns
  const lastColumn = worksheet.columnCount;
  if (lastColumn > 1) {
    worksheet.mergeCells(`A${footerRow}:${String.fromCharCode(64 + lastColumn)}${footerRow}`);
  }

  const buffer = await workbook.xlsx.writeBuffer();
  
  console.log(`âœ… Excel generated with ${currentRow - 1} rows and ${worksheet.columnCount} columns`);
  
  return { 
    buffer, 
    filename, 
    mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 
    size: buffer.length 
  };
}



  // âœ… FIXED: TXT Generation with ACTUAL content
  static async generateTXT(content, filename) {
    const formattedContent = `${content}\n\n---\nGenerated by QhashAI - ${new Date().toLocaleDateString()}`;
    const buffer = Buffer.from(formattedContent, 'utf8');
    return { buffer, filename, mimeType: 'text/plain', size: buffer.length };
  }
}
// âœ… NEW: Helper function to parse formatted text
function parseFormattedText(text) {
  const textRuns = [];
  let currentIndex = 0;
  
  // âœ… Enhanced regex to handle bold formatting
  const boldRegex = /\*\*(.*?)\*\*/g;
  let match;
  
  while ((match = boldRegex.exec(text)) !== null) {
    const [fullMatch, boldText] = match;
    const matchStart = match.index;
    const matchEnd = match.index + fullMatch.length;
    
    // Add text before the bold part (if any)
    if (matchStart > currentIndex) {
      const beforeText = text.substring(currentIndex, matchStart);
      if (beforeText.trim()) {
        textRuns.push(new TextRun({ 
          text: beforeText, 
          size: 24 
        }));
      }
    }
    
    // Add the bold text
    textRuns.push(new TextRun({ 
      text: boldText, 
      size: 24, 
      bold: true 
    }));
    
    currentIndex = matchEnd;
  }
  
  // Add remaining text after the last bold part
  if (currentIndex < text.length) {
    const remainingText = text.substring(currentIndex);
    if (remainingText.trim()) {
      textRuns.push(new TextRun({ 
        text: remainingText, 
        size: 24 
      }));
    }
  }
  
  // If no bold formatting found, return the entire text as a single run
  if (textRuns.length === 0) {
    textRuns.push(new TextRun({ 
      text: text, 
      size: 24 
    }));
  }
  
  return textRuns;
}
module.exports = FileGenerator;
